.
├── README.md
├── combined_subi_app_clean.txt
├── components.json
├── create_subi_file_structure.sh
├── logs
│   ├── auth-error-1731650830191.log
│   ├── auth-error-1731650873416.log
│   ├── auth-error-1731651551209.log
│   ├── auth-error-1731651923612.log
│   ├── cheerio-error-1731625028238.log
│   ├── cheerio-error-1731625272351.log
│   ├── cheerio-error-1731625461299.log
│   ├── cheerio-error-1731647658514.log
│   ├── cheerio-load-1731647658508.log
│   ├── converted-response-1731625028236.log
│   ├── converted-response-1731625272349.log
│   ├── converted-response-1731625461297.log
│   ├── fatal-error-1731650830194.log
│   ├── fatal-error-1731650873417.log
│   ├── raw-response-1731625028225.log
│   ├── raw-response-1731625272340.log
│   ├── raw-response-1731625461289.log
│   ├── raw-response-1731647658464.log
│   ├── request-1731625026842.log
│   ├── request-1731625270762.log
│   ├── request-1731625459867.log
│   └── request-1731647656313.log
├── next-env.d.ts
├── next.config.js
├── package-lock.json
├── package.json
├── postcss.config.js
├── postcss.config.mjs
├── src
│   ├── app
│   │   ├── dashboard
│   │   │   └── page.tsx
│   │   ├── favicon.ico
│   │   ├── fonts
│   │   │   ├── GeistMonoVF.woff
│   │   │   └── GeistVF.woff
│   │   ├── globals.css
│   │   ├── layout.tsx
│   │   ├── login
│   │   │   └── page.tsx
│   │   ├── manual-entry
│   │   │   └── page.tsx
│   │   ├── page.tsx
│   │   └── register
│   │       └── page.tsx
│   ├── components
│   │   ├── BusinessDataForm.tsx
│   │   ├── DashboardLayout.tsx
│   │   ├── EnhancedDashboard.tsx
│   │   ├── UrlInput.tsx
│   │   ├── UrlInputWrapper.tsx
│   │   └── ui
│   │       ├── button.tsx
│   │       ├── card.tsx
│   │       ├── floating-label-input.tsx
│   │       ├── form.tsx
│   │       ├── input.tsx
│   │       ├── label.tsx
│   │       ├── switch.tsx
│   │       ├── tabs.tsx
│   │       ├── textarea.tsx
│   │       ├── toast.tsx
│   │       ├── toaster.tsx
│   │       └── use-toast.ts
│   ├── hooks
│   │   └── useUser.ts
│   ├── lib
│   │   ├── data-transformations.ts
│   │   ├── json-utils.ts
│   │   ├── scraper.ts
│   │   ├── scraping-utils.ts
│   │   ├── scrapingbee-client.ts
│   │   ├── scrapingbee-utils.ts
│   │   ├── supabase-client.ts
│   │   ├── supabase.ts
│   │   └── utils.ts
│   ├── middleware.ts
│   ├── pages
│   │   ├── api
│   │   │   └── scrape.ts
│   │   └── dummy_listing.html
│   └── types
│       └── index.ts
├── subi_app_clean_structure.txt
├── tailwind.config.ts
└── tsconfig.json

16 directories, 76 files
-e 

====== CONTENT OF CRITICAL FILES ======

-e 
File: next.config.js

/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  env: {
    SCRAPINGBEE_API_KEY: process.env.SCRAPINGBEE_API_KEY,
  },
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'Strict-Transport-Security',
            value: 'max-age=31536000; includeSubDomains; preload',
          },
          {
            key: 'X-Frame-Options',
            value: 'SAMEORIGIN',
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'Referrer-Policy',
            value: 'strict-origin-when-cross-origin',
          },
        ],
      },
    ];
  },
};

module.exports = nextConfig;-e 

File: src/pages/api/scrape.ts

import { NextApiRequest, NextApiResponse } from 'next'
import { ScrapingBeeClient } from 'scrapingbee'
import * as cheerio from 'cheerio'
import { createClient } from '@supabase/supabase-js'
import { v4 as uuidv4 } from 'uuid'
import { ScrapedData } from '@/types'

const client = new ScrapingBeeClient(process.env.SCRAPINGBEE_API_KEY || '')

// Initialize Supabase client
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL || '',
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || ''
)

const safeExtract = ($: cheerio.CheerioAPI, selector: string): string => {
  try {
    return $(selector).first().text().trim() || 'N/A'
  } catch (error) {
    console.error(`Error extracting ${selector}:`, error)
    return 'N/A'
  }
}

const cleanPrice = (text: string): string => {
  const match = text.match(/\$[\d,]+/)
  return match ? match[0].replace(/[,$]/g, '') : '0'
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method Not Allowed' })
  }

  try {
    const { url, render_js = false } = req.body

    // Check for authentication
    const { data: { session }, error: sessionError } = await supabase.auth.getSession()
    const profile_id = session?.user?.id || null

    if (sessionError) {
      console.error('Session error:', sessionError)
    }

    const response = await client.get({
      url: url,
      params: { render_js }
    })

    const responseText = Buffer.isBuffer(response.data) 
      ? response.data.toString('utf-8')
      : typeof response.data === 'string' 
        ? response.data 
        : JSON.stringify(response.data)

    const $ = cheerio.load(responseText)
    
    const scrapedData: ScrapedData = {
      business_name: safeExtract($, 'h1'),
      asking_price: cleanPrice(safeExtract($, '.price strong')),
      annual_revenue: cleanPrice(safeExtract($, '#revenue strong')),
      cash_flow: cleanPrice(safeExtract($, '#profit strong')),
      location: safeExtract($, '#address'),
      description: safeExtract($, '.listing-paragraph'),
      broker: safeExtract($, '.broker-details h4'),
      year_established: safeExtract($, 'dt:contains("Years established") + dd')
    }

    // Store scraped data with or without profile_id
    const { data, error: insertError } = await supabase
      .from('scraped_data')
      .insert([{
        id: uuidv4(),
        profile_id: profile_id,
        ...scrapedData,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      }])
      .select()

    if (insertError) {
      console.error('Error storing scraped data:', insertError)
      // Log the error but continue to return the scraped data to the user
    } else {
      console.log('Successfully stored scraped data:', data)
    }

    res.status(200).json({
      success: true,
      data: scrapedData,
      authenticated: !!profile_id
    })

  } catch (error: any) {
    console.error('Scraping error:', error)
    res.status(500).json({ 
      message: 'Internal Server Error', 
      details: error.message 
    })
  }
}-e 

File: src/components/EnhancedDashboard.tsx

import React, { useState } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { UrlInput } from '@/components/UrlInput'
import { BusinessDataForm } from '@/components/BusinessDataForm'
import { ScrapedData } from '@/types'

export function EnhancedDashboard() {
  const [businessData, setBusinessData] = useState<ScrapedData | null>(null)

  const handleDataScraped = (data: ScrapedData) => {
    setBusinessData(data)
  }

  const handleFormSubmit = (data: ScrapedData) => {
    console.log('Form submitted:', data)
    // Handle form submission logic here
  }

  return (
    <Tabs defaultValue="scrape" className="w-full">
      <TabsList>
        <TabsTrigger value="scrape">Scrape Business Data</TabsTrigger>
        <TabsTrigger value="manual">Manual Entry</TabsTrigger>
      </TabsList>
      <TabsContent value="scrape">
        <Card>
          <CardHeader>
            <CardTitle>Scrape Business Data</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <UrlInput onDataScraped={handleDataScraped} />
            {businessData && (
              <BusinessDataForm onSubmit={handleFormSubmit} initialData={businessData} />
            )}
          </CardContent>
        </Card>
      </TabsContent>
      <TabsContent value="manual">
        <Card>
          <CardHeader>
            <CardTitle>Manual Data Entry</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <BusinessDataForm onSubmit={handleFormSubmit} />
          </CardContent>
        </Card>
      </TabsContent>
    </Tabs>
  )
}-e 

File: src/components/UrlInput.tsx

import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { useToast } from '@/components/ui/use-toast'
import { ScrapedData } from '@/types'

export interface UrlInputProps {
  onDataScraped: (data: ScrapedData) => void
}

export function UrlInput({ onDataScraped }: UrlInputProps) {
  const [url, setUrl] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const { toast } = useToast()

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)

    try {
      const response = await fetch('/api/scrape', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ url }),
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.message || 'Failed to scrape data')
      }

      onDataScraped(data.data)
      toast({
        title: 'Success',
        description: 'Successfully scraped business data',
      })
    } catch (error) {
      console.error('Error:', error)
      toast({
        variant: 'destructive',
        title: 'Error',
        description: 'Failed to scrape business data. Please try again.',
      })
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <form onSubmit={handleSubmit} className="flex gap-2">
      <Input
        type="url"
        value={url}
        onChange={(e) => setUrl(e.target.value)}
        placeholder="Enter business listing URL"
        required
        className="flex-grow"
      />
      <Button type="submit" disabled={isLoading}>
        {isLoading ? 'Scraping...' : 'Scrape'}
      </Button>
    </form>
  )
}-e 

File: src/components/BusinessDataForm.tsx

import React from 'react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { ScrapedData } from '@/types'

interface BusinessDataFormProps {
  onSubmit: (data: ScrapedData) => void
  initialData?: ScrapedData
}

export function BusinessDataForm({ onSubmit, initialData }: BusinessDataFormProps) {
  const [formData, setFormData] = React.useState<ScrapedData>(
    initialData || {
      business_name: '',
      asking_price: '',
      annual_revenue: '',
      cash_flow: '',
      location: '',
      description: '',
      broker: '',
      year_established: '',
    }
  )

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target
    setFormData((prev) => ({ ...prev, [name]: value }))
  }

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    onSubmit(formData)
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <Input
        name="business_name"
        value={formData.business_name}
        onChange={handleChange}
        placeholder="Business Name"
        required
      />
      <Input
        name="asking_price"
        value={formData.asking_price}
        onChange={handleChange}
        placeholder="Asking Price"
        required
      />
      <Input
        name="annual_revenue"
        value={formData.annual_revenue}
        onChange={handleChange}
        placeholder="Annual Revenue"
        required
      />
      <Input
        name="cash_flow"
        value={formData.cash_flow}
        onChange={handleChange}
        placeholder="Cash Flow"
        required
      />
      <Input
        name="location"
        value={formData.location}
        onChange={handleChange}
        placeholder="Location"
        required
      />
      <Textarea
        name="description"
        value={formData.description}
        onChange={handleChange}
        placeholder="Description"
        required
      />
      <Input
        name="broker"
        value={formData.broker}
        onChange={handleChange}
        placeholder="Broker"
        required
      />
      <Input
        name="year_established"
        value={formData.year_established}
        onChange={handleChange}
        placeholder="Year Established"
        required
      />
      <Button type="submit">Submit</Button>
    </form>
  )
}-e 

File: src/lib/scrapingbee-client.ts

import axios from 'axios'

export interface ScrapedData {
  businessName?: string
  askingPrice?: string
  annualRevenue?: string
  cashFlow?: string
  location?: string
  description?: string
  broker?: string
  yearEstablished?: string
}

export async function scrapeBusinessData(url: string, isAdvancedMode: boolean, customQueries?: string[]): Promise<ScrapedData> {
  try {
    // 1. Create the request payload
    const payload = {
      api_key: process.env.NEXT_PUBLIC_SCRAPINGBEE_API_KEY,
      url: url,
      // Add any additional parameters required by ScrapingBee API
    }

    // 2. Make the API request
    const response = await axios.post('/api/scrape', payload)

    // 3. Check the response status
    if (response.status !== 200) {
      throw new Error(`ScrapingBee API returned status ${response.status}`)
    }

    // 4. Process the response data and extract relevant information
    const scrapedData: ScrapedData = {
      // Map the response data to the ScrapedData interface
      // This is a placeholder implementation and should be adjusted based on the actual API response
      businessName: response.data.businessName,
      askingPrice: response.data.askingPrice,
      annualRevenue: response.data.annualRevenue,
      cashFlow: response.data.cashFlow,
      location: response.data.location,
      description: response.data.description,
      broker: response.data.broker,
      yearEstablished: response.data.yearEstablished,
    }

    return scrapedData
  } catch (error) {
    console.error('Error scraping business data:', error)
    throw new Error('Failed to scrape business data. Please try again later.')
  }
}-e 

File: src/lib/scraping-utils.ts

import { supabase } from './supabase'

// Simple in-memory cache
const cache: { [key: string]: any } = {}

export function checkRateLimit(userId: string): boolean {
  // Implement rate limiting logic here
  // For now, we'll always return true
  return true
}

export function getCachedData(url: string): any {
  return cache[url]
}

export function cacheData(url: string, data: any): void {
  cache[url] = data
}

export async function storeScrapedData(userId: string, url: string, data: any): Promise<void> {
  try {
    const { error } = await supabase
      .from('scraped_data')
      .insert({ user_id: userId, url, data })

    if (error) throw error
  } catch (error) {
    console.error('Error storing scraped data:', error)
    throw error
  }
}-e 

File: src/types/index.ts

export interface ScrapedData {
  business_name: string;
  asking_price: string;
  annual_revenue: string;
  cash_flow: string;
  location: string;
  description: string;
  broker: string;
  year_established: string;
}-e 

File: package.json

{
  "name": "subi-app-clean",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.9.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-slot": "^1.0.2",
    "@radix-ui/react-switch": "^1.1.1",
    "@radix-ui/react-tabs": "^1.1.1",
    "@radix-ui/react-toast": "^1.2.2",
    "@supabase/auth-helpers-nextjs": "^0.8.7",
    "@supabase/supabase-js": "^2.38.4",
    "axios": "^1.7.7",
    "cheerio": "^1.0.0",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.0.0",
    "lucide-react": "^0.292.0",
    "next": "14.0.3",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-hook-form": "^7.53.2",
    "scrapingbee": "^1.7.5",
    "tailwind-merge": "^2.0.0",
    "tailwindcss-animate": "^1.0.7",
    "uuid": "^11.0.3",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@types/uuid": "^10.0.0",
    "@typescript-eslint/eslint-plugin": "^5.62.0",
    "@typescript-eslint/parser": "^5.62.0",
    "autoprefixer": "^10.0.1",
    "eslint": "^8",
    "eslint-config-next": "14.0.3",
    "postcss": "^8",
    "tailwindcss": "^3.3.0",
    "typescript": "^5.1.6"
  }
}
-e 

File: .eslintrc.json

{
  // 1. Extend from recommended configs
  "extends": [
    "next/core-web-vitals",
    "plugin:@typescript-eslint/recommended"
  ],
  
  // 2. Specify the parser for TypeScript
  "parser": "@typescript-eslint/parser",
  
  // 3. Add TypeScript-specific plugins
  "plugins": ["@typescript-eslint"],
  
  // 4. Set as root configuration
  "root": true,

  // 5. (Optional) Add any custom rules here
  "rules": {
    // Example: "@typescript-eslint/explicit-module-boundary-types": "off"
  }
}-e 

File: src/app/dashboard/page.tsx

'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs'
import { User } from '@supabase/supabase-js'
import DashboardLayout from '@/components/DashboardLayout'
import { EnhancedDashboard } from '@/components/EnhancedDashboard'
import { Button } from '@/components/ui/button'

export default function DashboardPage() {
  const router = useRouter()
  const [user, setUser] = useState<User | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const supabase = createClientComponentClient()

  useEffect(() => {
    const getUser = async () => {
      const { data: { user } } = await supabase.auth.getUser()
      setUser(user)
      setIsLoading(false)
      if (!user) {
        router.push('/login')
      }
    }
    getUser()
  }, [supabase, router])

  const handleSignOut = async () => {
    await supabase.auth.signOut()
    router.push('/login')
  }

  if (isLoading) {
    return <div>Loading...</div>
  }

  if (!user) {
    return null // Router will redirect to login page
  }

  return (
    <DashboardLayout user={user}>
      <EnhancedDashboard />
      <div className="mt-4">
        <Button onClick={handleSignOut} variant="outline">Sign Out</Button>
      </div>
    </DashboardLayout>
  )
}-e 

File: src/app/login/page.tsx

'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { zodResolver } from "@hookform/resolvers/zod"
import { useForm } from "react-hook-form"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { useToast } from "@/components/ui/use-toast"
import { supabase } from '@/lib/supabase' // Import supabase client

const formSchema = z.object({
  email: z.string().email({
    message: "Please enter a valid email address.",
  }),
  password: z.string().min(8, {
    message: "Password must be at least 8 characters.",
  }),
})

export default function LoginPage() {
  const [isLoading, setIsLoading] = useState(false)
  const router = useRouter()
  const { toast } = useToast()

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      email: "",
      password: "",
    },
  })

  async function onSubmit(values: z.infer<typeof formSchema>) {
    setIsLoading(true)
    try {
      const { data, error } = await supabase.auth.signInWithPassword({
        email: values.email,
        password: values.password,
      })

      if (error) throw error

      toast({
        title: "Login Successful",
        description: "You have been logged in successfully.",
      })
      router.push('/dashboard')
    } catch (error) {
      toast({
        title: "Login Failed",
        description: error instanceof Error ? error.message : "An unexpected error occurred",
        variant: "destructive",
      })
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="container mx-auto max-w-md p-4">
      <h1 className="text-2xl font-bold mb-4">Login</h1>
      <Form {...form}>
        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
          <FormField
            control={form.control}
            name="email"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Email</FormLabel>
                <FormControl>
                  <Input placeholder="Enter your email" {...field} className="w-full px-3 py-2 border rounded-md" />
                </FormControl>
                <FormDescription>
                  We will never share your email.
                </FormDescription>
                <FormMessage />
              </FormItem>
            )}
          />
          <FormField
            control={form.control}
            name="password"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Password</FormLabel>
                <FormControl>
                  <Input type="password" placeholder="Enter your password" {...field} className="w-full px-3 py-2 border rounded-md" />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
          <Button type="submit" disabled={isLoading} className="w-full bg-blue-500 text-white py-2 rounded-md hover:bg-blue-600">
            {isLoading ? "Logging in..." : "Login"}
          </Button>
        </form>
      </Form>
    </div>
  )
}-e 

File: src/app/register/page.tsx

'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import Link from 'next/link'
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { useToast } from '@/components/ui/use-toast'

export default function RegisterPage() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [confirmPassword, setConfirmPassword] = useState('')
  const [loading, setLoading] = useState(false)
  const router = useRouter()
  const { toast } = useToast()
  const supabase = createClientComponentClient()

  const handleRegister = async (e: React.FormEvent) => {
    e.preventDefault()
    setLoading(true)

    if (password !== confirmPassword) {
      toast({
        title: "Password Mismatch",
        description: "The passwords you entered do not match. Please try again.",
        variant: "destructive",
      })
      setLoading(false)
      return
    }

    const { error } = await supabase.auth.signUp({
      email,
      password,
    })

    if (error) {
      toast({
        title: "Registration Failed",
        description: error.message,
        variant: "destructive",
      })
    } else {
      toast({
        title: "Registration Successful",
        description: "Please check your email to confirm your account.",
      })
      router.push('/login')
    }

    setLoading(false)
  }

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-100">
      <div className="w-full max-w-md space-y-8 rounded-xl bg-white p-10 shadow-md">
        <div className="text-center">
          <h1 className="text-3xl font-bold">Register for SUBI</h1>
          <p className="mt-2 text-sm text-gray-600">
            Create an account to start analyzing businesses
          </p>
        </div>
        <form onSubmit={handleRegister} className="mt-8 space-y-6">
          <div className="space-y-4">
            <div>
              <Label htmlFor="email">Email address</Label>
              <Input
                id="email"
                name="email"
                type="email"
                autoComplete="email"
                required
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                className="mt-1"
              />
            </div>
            <div>
              <Label htmlFor="password">Password</Label>
              <Input
                id="password"
                name="password"
                type="password"
                autoComplete="new-password"
                required
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="mt-1"
              />
            </div>
            <div>
              <Label htmlFor="confirm-password">Confirm Password</Label>
              <Input
                id="confirm-password"
                name="confirm-password"
                type="password"
                autoComplete="new-password"
                required
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
                className="mt-1"
              />
            </div>
          </div>

          <div>
            <Button type="submit" className="w-full" disabled={loading}>
              {loading ? 'Registering...' : 'Register'}
            </Button>
          </div>
        </form>
        <div className="mt-4 text-center text-sm">
          <p>
            Already have an account?{' '}
            <Link href="/login" className="font-medium text-blue-600 hover:text-blue-500">
              Log in here
            </Link>
          </p>
        </div>
      </div>
    </div>
  )
}-e 

File: src/lib/utils.ts

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
